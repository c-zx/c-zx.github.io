<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>c-zx's blog</title><link href="https://c-zx.github.io/" rel="alternate"></link><link href="https://c-zx.github.io/feeds/all.atom.xml" rel="self"></link><id>https://c-zx.github.io/</id><updated>2021-07-01T18:00:00+08:00</updated><entry><title>递归那些事儿</title><link href="https://c-zx.github.io/about-recursion.html" rel="alternate"></link><published>2021-07-01T18:00:00+08:00</published><updated>2021-07-01T18:00:00+08:00</updated><author><name>Cao ZhenXiang</name></author><id>tag:c-zx.github.io,2021-07-01:/about-recursion.html</id><summary type="html">&lt;p&gt;什么是递归？递归的优缺点，以及针对递归可能的优化（尾递归优化）。&lt;/p&gt;</summary><content type="html">&lt;h2&gt;什么是递归？&lt;/h2&gt;
&lt;p&gt;如果你在词典里查询&lt;code&gt;recursion&lt;/code&gt;（递归），会看到以下解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Recursion (-sh?n), n. [L. recursio. See Recur.] The act of &lt;strong&gt;recurring&lt;/strong&gt;; return. [Obs.] Boyle.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如你并不知道&lt;code&gt;recurring&lt;/code&gt;是什么意思，于是继续在词典里查询&lt;code&gt;recur&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Recur (r?k?r), v. i. [imp. &amp;amp; p. p. Recurred (-k?rd); p. pr. &amp;amp; vb. n. Recurring.] [L. recurrere; pref. re- re- + currere to run. See Current.]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;To come back; to return again or repeatedly; to come again to mind.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;When any word has been used to signify an idea, the old idea will recur in the mind when the word is heard. I. Watts.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To occur at a stated interval, or according to some regular rule; as, the fever will recur to-night.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To resort; to have recourse; to go for help.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If, to avoid succession in eternal existence, they recur to the “punctum stans” of the schools, they will thereby very little help us to a more positive idea of infinite duration. Locke.&lt;/p&gt;
&lt;p&gt;Recurring decimal (Math.), a circulating decimal. See under Decimal. -- Recurring series (Math.), an algebraic series in which the coefficients of the several terms can be expressed by means of certain preceding coefficients and constants in one uniform manner.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，&lt;code&gt;recursion&lt;/code&gt;的意思就是&lt;code&gt;The act of coming back&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而在词典里查询&lt;code&gt;recursion&lt;/code&gt;这个词的过程本身，其实就是一个非常简单的递归。&lt;/p&gt;
&lt;p&gt;PS: 其实日常的学习也是一个类似递归的过程。比如说，为了搭建博客，需要了解博客框架的使用。而使用博客框架又需要学习Markdown的基本语法。写完博客如果要优化搜索引擎排名，还需要学习一些SEO技巧。如果想要定制博客的页面，就需要学习CSS的基本用法等等。学习完这一切后，还不能忘了最初搭建博客是为了写些什么。&lt;/p&gt;
&lt;h2&gt;递归的优点&lt;/h2&gt;
&lt;p&gt;使用递归进行编程，通常代码逻辑本身会比较简单，比如上述过程可以这样用Python表示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;words&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_definition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;words&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;understand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
            &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;lookup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;递归的缺点&lt;/h2&gt;
&lt;p&gt;使用递归时，&lt;strong&gt;内存&lt;/strong&gt;消耗往往会比较大。比如在上述查询单词含义的过程，如果含义本身里有你不明白的单词（&lt;code&gt;recur&lt;/code&gt;），你不仅要查询这个单词（&lt;code&gt;recur&lt;/code&gt;）本身的含义，还不能忘记原本要查的单词的意思（&lt;code&gt;The act of recurring&lt;/code&gt;）。上述例子只是一个非常简单的例子，所以可能需要“记忆”的内容显得不是很多。但假如你刚刚入门一种语言，查询一个词，而含义里却有更多不认识的词，然后依次查询又分别遇到更多更多不认识的词。这样查询起来想必会很累。&lt;/p&gt;
&lt;p&gt;PS: 所以如果你刚刚开始学习一门语言，你的词典的释义最好是用你的母语写的！&lt;/p&gt;
&lt;h2&gt;递归会遇到的问题&lt;/h2&gt;
&lt;p&gt;使用递归时，最常见的问题应该就是&lt;strong&gt;无限递归&lt;/strong&gt;了。回到我们刚刚查询&lt;code&gt;recur&lt;/code&gt;含义的过程，它的第三种含义是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To resort; to have &lt;strong&gt;recourse&lt;/strong&gt;; to go for help&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如你不知道&lt;code&gt;recourse&lt;/code&gt;的含义，再去词典里查询，会发现&lt;code&gt;recourse&lt;/code&gt;的第一种含义就是&lt;code&gt;To return; to recur&lt;/code&gt;！这下好了，为了理解&lt;code&gt;recur&lt;/code&gt;，你需要明白&lt;code&gt;recourse&lt;/code&gt;；可是为了明白&lt;code&gt;recourse&lt;/code&gt;，你又需要理解&lt;code&gt;recur&lt;/code&gt;，这根本是个死循环吗！&lt;/p&gt;
&lt;p&gt;如果你写的代码陷入了无限递归，多半就会报错显示&lt;code&gt;Stack overflow&lt;/code&gt;！其中&lt;code&gt;Stack&lt;/code&gt;是用于存储局部变量的数据结构，而由于计算机陷入了无限递归，在不能忘记原本词的含义的同时，还要记住无限多的&lt;code&gt;recur&lt;/code&gt;和&lt;code&gt;recourse&lt;/code&gt;的含义，最终内存用尽&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;，就只好报错了。&lt;/p&gt;
&lt;h2&gt;针对递归的优化&lt;/h2&gt;
&lt;p&gt;一些编程语言实现（比如Scheme）会使用一种叫做&lt;strong&gt;尾递归优化&lt;/strong&gt;(Tail Recursion Optimization)的技术。如果递归在函数的&lt;strong&gt;最后一步&lt;/strong&gt;产生，那么这个递归就是尾递归。&lt;/p&gt;
&lt;p&gt;Tail Recursion Optimization 有时也叫 Tail Recursion Elimination。也就是&lt;strong&gt;尾递归消除&lt;/strong&gt;。因为尾递归优化的原理就是将尾递归转换为迭代，这样计算机就不用记住前一次递归中各个变量的值，也可以减少函数调用的性能损失。&lt;/p&gt;
&lt;p&gt;不过有时候，并不是很容易写出能进行&lt;code&gt;尾递归优化&lt;/code&gt;的代码，与其用递归，不如直接用迭代(Iterate)。&lt;/p&gt;
&lt;p&gt;就阶乘函数举个例子。&lt;/p&gt;
&lt;p&gt;以下是阶乘函数的直接递归实现:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;PS: 虽然递归在函数的最后一行产生，但是注意函数返回的是&lt;code&gt;fact(num-1) * num&lt;/code&gt;，
因此最后一步并不是对&lt;code&gt;fact&lt;/code&gt;的函数调用，而是计算（&lt;code&gt;fact&lt;/code&gt;的返回值与&lt;code&gt;num&lt;/code&gt;）的乘积。&lt;/p&gt;
&lt;p&gt;为了返回正确的值，必须要知道&lt;code&gt;fact&lt;/code&gt;的返回值和&lt;code&gt;num&lt;/code&gt;的内容，因此&lt;code&gt;num&lt;/code&gt;并不能被优化掉。&lt;/p&gt;
&lt;p&gt;如果用迭代可以这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而支持尾递归优化的实现是这样的&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2"&gt;2&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact_tc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fact&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看出，直接递归和迭代的实现都很直接；相比来说，支持尾递归优化的实现就比较麻烦。&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;一般来说，并非内存用尽才会报错&lt;code&gt;Stack overflow&lt;/code&gt;。很多编程语言会设置一个&lt;code&gt;stack limit&lt;/code&gt;来避免无限递归耗尽内存，所以一般编程语言抛出&lt;code&gt;Stack overflow&lt;/code&gt;的时候，往往只是&lt;code&gt;stack&lt;/code&gt;的大小超过了原本设置的限制。&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;为了代码可读性，这里用的是Python。不过CPython（官方实现）是不支持尾递归优化的。因为&lt;a href="https://en.wikipedia.org/wiki/Guido_van_Rossum"&gt;Guido&lt;/a&gt;认为尾递归优化会破坏Traceback，影响Debugging.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="misc"></category><category term="递归"></category><category term="编程"></category></entry></feed>